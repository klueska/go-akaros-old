#!/bin/bash
eval $(go env)

AKAROS_SERVER=localhost
AKAROS_PORT=5555
TIMEOUT=300

AKAROS_GOROOT=/go
AKAROS_MNT=/mnt
HOST_MNT=$GOROOT/misc/akaros/mnt
AKAROS_PWD=$(pwd | sed "s;$GOROOT;$AKAROS_GOROOT;")

EXEC_DIR=$(dirname $1)
BUILD_DIR=${EXEC_DIR%_test}
EXEC_FILE=$(basename $1)
CPIO_FILE=${EXEC_FILE%.test}.cpio

# Execute a set of commands remotely on akaros
rpc()
{
	echo "$@" | netcat -w $TIMEOUT $AKAROS_SERVER $AKAROS_PORT
}

# Whenever the go program is done executing, remove the $BUILD_DIR on both the
# host and the client. We encapsulate this in a function here so that it will
# also happen upon pressing Ctrl-C, or otherwise exiting.
cleanup()
{
	rm -rf $HOST_MNT/$BUILD_DIR
	echo "rm -rf $BUILD_DIR 2>/dev/null;" | netcat $AKAROS_SERVER $AKAROS_PORT
}
die()
{
	cleanup
	echo "Program execution interrupted early"
	exit 1
}
trap die SIGINT
trap die SIGTERM
trap die SIGKILL

# Create a cpio archive of the folder where the go program resides and put it
# in $HOST_MNT/$BUILD_DIR
mkdir -p $HOST_MNT/$BUILD_DIR
find $BUILD_DIR | cpio -H newc -o > $HOST_MNT/$BUILD_DIR/$CPIO_FILE 2>/dev/null

# Create $BUILD_DIR on akaros
echo "mkdir -p ${BUILD_DIR#/}" | netcat $AKAROS_SERVER $AKAROS_PORT

# Copy the cpio archive into $BUILD_DIR on akaros
rpc "cp $AKAROS_MNT/$BUILD_DIR/$CPIO_FILE $BUILD_DIR >/dev/null"

# Extract the cpio archive into / on akaros
rpc "cpio -d -i < $BUILD_DIR/$CPIO_FILE 2>/dev/null;"

# Execute the go program on akaros, printing its output, followed by its exit
# code. Store this in a bash variable.
OUTPUT=$(rpc "export GOROOT=$AKAROS_GOROOT; \
              cd $AKAROS_PWD; \
              $1 ${@:2}; \
              EXIT=\$?; \
              echo ""; \
              echo \$EXIT")

# Manually do the cleanup if we reach this point
cleanup

# If there was no output from the go program, something went wrong, so error out
if [ "$OUTPUT" = "" ]; then
	echo "Could not execute binary on Akaros client. Make sure the listen1 program is running."
	exit 1
fi

# Otherwise, Extract the exit code from the output
EXIT=$(echo "$OUTPUT" | tail -1)
OUTPUT=$(echo "$OUTPUT" | head -n -1)

# If the last line in the output is blank, remove it (this is necessary for
# making sure the exit code was printed on a line by itself, when the actual
# output of the go executable doesn't end in a newline)
if [ "$(echo "$OUTPUT" | tail -1)" = "" ]; then
	OUTPUT=$(echo "$OUTPUT" | head -n -1)
fi

# Print the remaining output of the go program to stdout
echo "$OUTPUT"

# And exit this script with the exit code from the go program
exit $EXIT

